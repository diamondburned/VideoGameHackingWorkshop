#!/usr/bin/env bash
set -e

reEvt="\/\/ (.*Event) is the (.*) event data\."
reCmd="\/\/ (.*Command) is the (.*) command data\."

main() {
	[[ $# < 1 ]] && {
		echo "usage: generate.sh <input go file>"
		exit 1
	}

	declare -A events
	declare -A commands
	
	while read -r line; do
		[[ "$line" =~ $reEvt ]] && {
			goType="${BASH_REMATCH[1]}"
			wsType="${BASH_REMATCH[2]}"
			events["$goType"]="$wsType"
		}
		[[ "$line" =~ $reCmd ]] && {
			goType="${BASH_REMATCH[1]}"
			wsType="${BASH_REMATCH[2]}"
			commands["$goType"]="$wsType"
		}
	done < "$1"

	name="${1%%.*}"

	generateEvents > "${name}_events.go"
	goimports -w "${name}_events.go"

	generateCommands > "${name}_commands.go"
	goimports -w "${name}_commands.go"
}

generateEvents() {
	cat<<'EOF'
// Code generated by generate.sh. DO NOT EDIT.

package vghw

import (
	"encoding/json"
	"fmt"

	"github.com/pkg/errors"
)
	
EOF
	
	for goType in "${!events[@]}"; {
		wsType="${events[$goType]}"
	
		cat<<EOF
// EventType implements vghw.Event.
func (ev *$goType) EventType() string { return "${events[$goType]}" }

// MarshalJSON implements vghw.Event.
func (ev *$goType) MarshalJSON() ([]byte, error) {
	type raw $goType
	return json.Marshal(struct{
		Type string \`json:"type"\`
		Data *raw   \`json:"d"\`
	}{
		Type: "${events[$goType]}",
		Data: (*raw)(ev),
	})
}

EOF
	}
	
	cat<<'EOF'
// UnmarshalEvent unmarshals a JSON body to an Event.
func UnmarshalEvent(raw json.RawMessage) (Event, error) {
	var partial struct {
		Type string `json:"type"`
	}

	if err := json.Unmarshal(raw, &partial); err != nil {
		return nil, err
	}

	var body struct {
		Data Event `json:"d"`
	}

	switch partial.Type {
EOF
	
	for goType in "${!events[@]}"; {
		wsType="${events[$goType]}"
		cat<<EOF
	case "$wsType":
		body.Data = &$goType{}
EOF
	}
	
	cat<<'EOF'
	default:
		return nil, fmt.Errorf("unknown event type %q", partial.Type)
	}

	if err := json.Unmarshal(raw, &body); err != nil {
		return nil, errors.Wrap(err, "cannot unmarshal event data")
	}

	return body.Data, nil
}
EOF
}

generateCommands() {
	cat<<'EOF'
// Code generated by generate.sh. DO NOT EDIT.

package vghw

import (
	"encoding/json"
	"fmt"

	"github.com/pkg/errors"
)
	
EOF
	
	for goType in "${!commands[@]}"; {
		wsType="${commands[$goType]}"
	
		cat<<EOF
// CommandType implements vghw.Command.
func (cmd *$goType) CommandType() string { return "${commands[$goType]}" }

// MarshalJSON implements vghw.Command.
func (cmd *$goType) MarshalJSON() ([]byte, error) {
	type raw $goType
	return json.Marshal(struct{
		Type string \`json:"type"\`
		Data *raw   \`json:"d"\`
	}{
		Type: "${commands[$goType]}",
		Data: (*raw)(cmd),
	})
}

EOF
	}
	
	cat<<'EOF'
// UnmarshalCommand unmarshals a JSON body to an Command.
func UnmarshalCommand(raw json.RawMessage) (Command, error) {
	var partial struct {
		Type string `json:"type"`
	}

	if err := json.Unmarshal(raw, &partial); err != nil {
		return nil, err
	}

	var body struct {
		Data Command `json:"d"`
	}

	switch partial.Type {
EOF
	
	for goType in "${!commands[@]}"; {
		wsType="${commands[$goType]}"
		cat<<EOF
	case "$wsType":
		body.Data = &$goType{}
EOF
	}
	
	cat<<'EOF'
	default:
		return nil, fmt.Errorf("unknown command type %q", partial.Type)
	}

	if err := json.Unmarshal(raw, &body); err != nil {
		return nil, errors.Wrap(err, "cannot unmarshal command data")
	}

	return body.Data, nil
}
EOF
}

main "$@"
